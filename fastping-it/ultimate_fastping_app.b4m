#!/usr/bin/env python3
"""
Ultimate FastPing Service + Customer Dashboard - COMPLETE INTEGRATION
====================================================================

Features:
- FastPing API with PayPal integration
- IP whitelisting with Redis caching  
- Automatic customer provisioning
- Proxy testing capabilities
- Complete billing system
- Resource management
- BEAUTIFUL Customer Dashboard with color themes!
- JWT authentication for dashboard
- Real-time usage statistics
- API endpoint access
"""

from flask import Flask, request, jsonify, render_template_string, Response, redirect, url_for
from flask_sqlalchemy import SQLAlchemy
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from functools import wraps
import redis
import sqlite3
import ipaddress
import time
from datetime import datetime, timedelta
import json
import uuid
import hashlib
import hmac
import requests
import orjson
import threading
from typing import Optional, Dict, Any, Tuple
import os
from dataclasses import dataclass, asdict
from enum import Enum
import jwt
import secrets

# Flask app initialization
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', secrets.token_hex(32))
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///fastping.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Database setup
db = SQLAlchemy(app)

# Rate limiter
limiter = Limiter(
    key_func=get_remote_address,
    default_limits=["1000 per hour"]
)
limiter.init_app(app)

# Redis setup for ultra-fast IP caching
try:
    redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)
    redis_client.ping()
    REDIS_AVAILABLE = True
    print("‚úÖ Redis connected")
except:
    REDIS_AVAILABLE = False
    print("‚ö†Ô∏è Redis not available - using database only")

# PayPal configuration
PAYPAL_CLIENT_ID = os.environ.get('PAYPAL_CLIENT_ID')
PAYPAL_CLIENT_SECRET = os.environ.get('PAYPAL_CLIENT_SECRET')
PAYPAL_WEBHOOK_ID = os.environ.get('PAYPAL_WEBHOOK_ID')

# Dashboard configuration
JWT_EXPIRY_HOURS = 24

class CustomerStatus(Enum):
    ACTIVE = "active"
    SUSPENDED = "suspended"
    EXPIRED = "expired"
    PENDING = "pending"

class ResourceType(Enum):
    IP_ONLY = "ip_only"
    IP_PORT = "ip_port"
    PORT_RANGE = "port_range"

# Database Models
class Customer(db.Model):
    __tablename__ = 'customers'
    
    id = db.Column(db.String(50), primary_key=True)
    email = db.Column(db.String(255), unique=True, nullable=False)
    company_name = db.Column(db.String(255))
    plan_type = db.Column(db.String(50), default='basic')
    status = db.Column(db.String(50), default='active')
    api_key = db.Column(db.String(100), unique=True, nullable=False)
    monthly_quota = db.Column(db.Integer, default=10000)
    current_usage = db.Column(db.Integer, default=0)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_login = db.Column(db.DateTime)
    billing_email = db.Column(db.String(255))
    
    # Dashboard authentication
    password_hash = db.Column(db.String(255))  # For dashboard login
    
    # Relationships
    resources = db.relationship('ResourceAllocation', backref='customer', lazy=True)
    usage_logs = db.relationship('UsageLog', backref='customer', lazy=True)

class ResourceAllocation(db.Model):
    __tablename__ = 'resource_allocations'
    
    id = db.Column(db.String(50), primary_key=True)
    customer_id = db.Column(db.String(50), db.ForeignKey('customers.id'), nullable=False)
    ip_address = db.Column(db.String(45), nullable=False)
    port_start = db.Column(db.Integer)
    port_end = db.Column(db.Integer)
    resource_type = db.Column(db.String(50), nullable=False)
    allocated_at = db.Column(db.DateTime, default=datetime.utcnow)
    expires_at = db.Column(db.DateTime)
    is_active = db.Column(db.Boolean, default=True)
    last_used = db.Column(db.DateTime)
    notes = db.Column(db.Text)

class ResourcePool(db.Model):
    __tablename__ = 'resource_pools'
    
    id = db.Column(db.String(50), primary_key=True)
    ip_address = db.Column(db.String(45), nullable=False)
    port_start = db.Column(db.Integer)
    port_end = db.Column(db.Integer)
    resource_type = db.Column(db.String(50), nullable=False)
    is_available = db.Column(db.Boolean, default=True)
    reserved_for_plan = db.Column(db.String(50))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class UsageLog(db.Model):
    __tablename__ = 'usage_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    customer_id = db.Column(db.String(50), db.ForeignKey('customers.id'), nullable=False)
    ip_address = db.Column(db.String(45), nullable=False)
    endpoint = db.Column(db.String(255), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    response_time_ms = db.Column(db.Float)
    success = db.Column(db.Boolean, default=True)
    user_agent = db.Column(db.Text)

class BillingPeriod(db.Model):
    __tablename__ = 'billing_periods'
    
    id = db.Column(db.String(50), primary_key=True)
    customer_id = db.Column(db.String(50), db.ForeignKey('customers.id'), nullable=False)
    period_start = db.Column(db.DateTime, nullable=False)
    period_end = db.Column(db.DateTime, nullable=False)
    total_requests = db.Column(db.Integer, default=0)
    total_bandwidth_mb = db.Column(db.Float, default=0)
    base_cost = db.Column(db.Float, default=0)
    overage_cost = db.Column(db.Float, default=0)
    total_cost = db.Column(db.Float, default=0)
    invoice_generated = db.Column(db.Boolean, default=False)
    paid = db.Column(db.Boolean, default=False)

# Ultimate Customer Manager
class UltimateCustomerManager:
    def __init__(self):
        self.cache_timeout = 300
        self.init_resource_pools()
        
    def init_resource_pools(self):
        """Initialize IP/port pools if empty"""
        if ResourcePool.query.count() == 0:
            # Add development IPs - including localhost for ALL plan types
            dev_ips = ['127.0.0.1', 'localhost', '10.0.1.100', '10.0.1.101', '10.0.1.102']
            
            # Add basic plan resources
            for ip in dev_ips:
                pool = ResourcePool(
                    id=str(uuid.uuid4()),
                    ip_address=ip,
                    resource_type=ResourceType.IP_ONLY.value,
                    reserved_for_plan='basic'
                )
                db.session.add(pool)
            
            # Add enterprise plan resources (same IPs, different plan)
            for ip in dev_ips:
                pool = ResourcePool(
                    id=str(uuid.uuid4()),
                    ip_address=ip,
                    resource_type=ResourceType.PORT_RANGE.value,
                    reserved_for_plan='enterprise'
                )
                db.session.add(pool)
            
            # Add premium IP+port combinations
            for i, ip in enumerate(['10.0.2.100', '10.0.2.101']):
                for port_start in [8000, 9000, 10000]:
                    pool = ResourcePool(
                        id=str(uuid.uuid4()),
                        ip_address=ip,
                        port_start=port_start,
                        port_end=port_start + 99,
                        resource_type=ResourceType.IP_PORT.value,
                        reserved_for_plan='premium'
                    )
                    db.session.add(pool)
            
            db.session.commit()
            print("‚úÖ Resource pools initialized")
    
    def create_customer_from_paypal(self, email: str, plan_type: str = 'basic') -> Tuple[bool, str]:
        """Create customer with automatic resource allocation"""
        try:
            customer_id = f"cust_{uuid.uuid4().hex[:12]}"
            api_key = f"ak_{hashlib.sha256(f'{customer_id}{time.time()}'.encode()).hexdigest()[:32]}"
            
            # Plan quotas
            quotas = {'basic': 10000, 'premium': 50000, 'enterprise': 200000}
            monthly_quota = quotas.get(plan_type, 10000)
            
            # Create customer
            customer = Customer(
                id=customer_id,
                email=email,
                plan_type=plan_type,
                api_key=api_key,
                monthly_quota=monthly_quota,
                status=CustomerStatus.ACTIVE.value
            )
            db.session.add(customer)
            
            # Allocate resources
            resource = self._allocate_resource(customer_id, plan_type)
            if not resource:
                db.session.rollback()
                return False, "No available resources"
            
            # Add to IP whitelist
            self._add_to_whitelist(resource.ip_address, customer_id, plan_type)
            
            db.session.commit()
            print(f"‚úÖ Customer created: {customer_id} with IP {resource.ip_address}")
            
            return True, customer_id
            
        except Exception as e:
            db.session.rollback()
            print(f"‚ùå Error creating customer: {e}")
            return False, str(e)
    
    def _allocate_resource(self, customer_id: str, plan_type: str) -> Optional[ResourceAllocation]:
        """Allocate resource based on plan type"""
        # Determine resource type - SIMPLIFIED for testing
        resource_type = ResourceType.IP_ONLY  # Use IP_ONLY for all plans to start
        
        # Find available resource for this plan type
        available_pool = ResourcePool.query.filter_by(
            resource_type=resource_type.value,
            is_available=True,
            reserved_for_plan=plan_type
        ).first()
        
        # If no exact match, try any available IP_ONLY resource
        if not available_pool:
            available_pool = ResourcePool.query.filter_by(
                resource_type=ResourceType.IP_ONLY.value,
                is_available=True
            ).first()
        
        if not available_pool:
            print(f"‚ùå No available resources found for plan {plan_type}")
            return None
        
        # Mark as allocated
        available_pool.is_available = False
        
        # Create allocation
        allocation = ResourceAllocation(
            id=str(uuid.uuid4()),
            customer_id=customer_id,
            ip_address=available_pool.ip_address,
            port_start=available_pool.port_start,
            port_end=available_pool.port_end,
            resource_type=resource_type.value,
            expires_at=datetime.utcnow() + timedelta(days=30)
        )
        db.session.add(allocation)
        
        print(f"‚úÖ Allocated {available_pool.ip_address} to customer {customer_id}")
        return allocation
    
    def _add_to_whitelist(self, ip_address: str, customer_id: str, plan_type: str):
        """Add IP to Redis whitelist cache"""
        rate_limits = {'basic': 100, 'premium': 500, 'enterprise': 2000}
        rate_limit = rate_limits.get(plan_type, 100)
        
        if REDIS_AVAILABLE:
            cache_key = f"whitelist:{ip_address}"
            cache_data = {
                'customer_id': customer_id,
                'plan_type': plan_type,
                'rate_limit': rate_limit,
                'expires_at': (datetime.utcnow() + timedelta(days=30)).isoformat()
            }
            redis_client.setex(cache_key, self.cache_timeout, json.dumps(cache_data))
            print(f"‚úÖ IP {ip_address} added to whitelist cache")
    
    def is_ip_allowed(self, ip_address: str) -> Tuple[bool, Optional[Dict[str, Any]]]:
        """Ultra-fast IP whitelist check with Redis"""
        # Redis cache first
        if REDIS_AVAILABLE:
            cache_key = f"whitelist:{ip_address}"
            cached_data = redis_client.get(cache_key)
            if cached_data:
                try:
                    data = json.loads(cached_data)
                    if datetime.fromisoformat(data['expires_at']) > datetime.utcnow():
                        return True, data
                except:
                    pass
        
        # Database fallback
        allocation = ResourceAllocation.query.filter_by(
            ip_address=ip_address,
            is_active=True
        ).first()
        
        if allocation and allocation.expires_at > datetime.utcnow():
            customer = Customer.query.get(allocation.customer_id)
            if customer and customer.status == CustomerStatus.ACTIVE.value:
                rate_limits = {'basic': 100, 'premium': 500, 'enterprise': 2000}
                data = {
                    'customer_id': customer.id,
                    'plan_type': customer.plan_type,
                    'rate_limit': rate_limits.get(customer.plan_type, 100),
                    'expires_at': allocation.expires_at.isoformat()
                }
                
                # Cache for next time
                if REDIS_AVAILABLE:
                    cache_key = f"whitelist:{ip_address}"
                    redis_client.setex(cache_key, self.cache_timeout, json.dumps(data))
                
                return True, data
        
        return False, None
    
    def check_rate_limit(self, ip_address: str, rate_limit: int) -> bool:
        """Check rate limit with Redis"""
        if REDIS_AVAILABLE:
            key = f"rate_limit:{ip_address}"
            current_count = redis_client.incr(key)
            if current_count == 1:
                redis_client.expire(key, 60)  # 1-minute window
            return current_count <= rate_limit
        return True  # No rate limiting without Redis
    
    def log_usage(self, ip_address: str, customer_id: str, endpoint: str, 
                  response_time_ms: float, success: bool = True):
        """Log usage for billing"""
        try:
            usage_log = UsageLog(
                customer_id=customer_id,
                ip_address=ip_address,
                endpoint=endpoint,
                response_time_ms=response_time_ms,
                success=success,
                user_agent=request.headers.get('User-Agent', '')
            )
            db.session.add(usage_log)
            db.session.commit()
        except Exception as e:
            print(f"Error logging usage: {e}")
            db.session.rollback()

# Dashboard Manager
class DashboardManager:
    def __init__(self):
        self.cache_timeout = 300
    
    def create_dashboard_account(self, customer_id: str, email: str, password: str) -> bool:
        """Create or update dashboard login for existing customer"""
        try:
            password_hash = hashlib.sha256(password.encode()).hexdigest()
            
            customer = Customer.query.get(customer_id)
            if customer:
                customer.password_hash = password_hash
                db.session.commit()
                return True
            return False
        except Exception as e:
            print(f"Error creating dashboard account: {e}")
            return False
    
    def authenticate_customer(self, email: str, password: str) -> Optional[Dict[str, Any]]:
        """Authenticate customer for dashboard login"""
        try:
            password_hash = hashlib.sha256(password.encode()).hexdigest()
            
            customer = Customer.query.filter_by(
                email=email, 
                password_hash=password_hash,
                status='active'
            ).first()
            
            if customer:
                customer.last_login = datetime.utcnow()
                db.session.commit()
                
                return {
                    'customer_id': customer.id,
                    'email': customer.email,
                    'api_key': customer.api_key
                }
            return None
        except Exception as e:
            print(f"Authentication error: {e}")
            return None
    
    def get_customer_config(self, customer_id: str) -> Optional[Dict[str, Any]]:
        """Get customer's resource allocation configuration"""
        cache_key = f"customer_config:{customer_id}"
        
        # Try cache first
        if REDIS_AVAILABLE:
            cached_data = redis_client.get(cache_key)
            if cached_data:
                return json.loads(cached_data)
        
        try:
            customer = Customer.query.get(customer_id)
            if not customer:
                return None
            
            allocations = ResourceAllocation.query.filter_by(
                customer_id=customer_id,
                is_active=True
            ).all()
            
            rate_limits = {'basic': 100, 'premium': 500, 'enterprise': 2000}
            
            config_data = {
                'customer_id': customer_id,
                'ips': [],
                'total_ips': len(allocations)
            }
            
            for allocation in allocations:
                config_data['ips'].append({
                    'ip_address': allocation.ip_address,
                    'plan_type': customer.plan_type,
                    'rate_limit': rate_limits.get(customer.plan_type, 100),
                    'created_at': allocation.allocated_at.strftime('%Y-%m-%d %H:%M'),
                    'expires_at': allocation.expires_at.strftime('%Y-%m-%d %H:%M') if allocation.expires_at else 'Never',
                    'notes': allocation.notes or f'Auto-allocated for {customer.plan_type} plan'
                })
            
            # Cache the result
            if REDIS_AVAILABLE:
                redis_client.setex(cache_key, self.cache_timeout, json.dumps(config_data))
            
            return config_data
            
        except Exception as e:
            print(f"Error getting customer config: {e}")
            return None
    
    def get_customer_stats(self, customer_id: str, days: int = 7) -> Dict[str, Any]:
        """Get customer usage statistics"""
        cache_key = f"customer_stats:{customer_id}:{days}"
        
        # Try cache first
        if REDIS_AVAILABLE:
            cached_data = redis_client.get(cache_key)
            if cached_data:
                return json.loads(cached_data)
        
        try:
            # Calculate date threshold
            date_threshold = datetime.utcnow() - timedelta(days=days)
            
            # Get usage logs for the period
            usage_logs = UsageLog.query.filter(
                UsageLog.customer_id == customer_id,
                UsageLog.timestamp >= date_threshold
            ).all()
            
            if not usage_logs:
                return {
                    'total_requests': 0,
                    'successful_requests': 0,
                    'success_rate': 0,
                    'avg_response_time': 0,
                    'min_response_time': 0,
                    'max_response_time': 0,
                    'active_days': 0,
                    'daily_breakdown': []
                }
            
            total_requests = len(usage_logs)
            successful_requests = sum(1 for log in usage_logs if log.success)
            response_times = [log.response_time_ms for log in usage_logs if log.response_time_ms]
            
            # Group by date for daily breakdown
            daily_data = {}
            for log in usage_logs:
                date_str = log.timestamp.strftime('%Y-%m-%d')
                if date_str not in daily_data:
                    daily_data[date_str] = {'requests': 0, 'response_times': []}
                daily_data[date_str]['requests'] += 1
                if log.response_time_ms:
                    daily_data[date_str]['response_times'].append(log.response_time_ms)
            
            daily_breakdown = []
            for date_str in sorted(daily_data.keys(), reverse=True):
                data = daily_data[date_str]
                avg_time = sum(data['response_times']) / len(data['response_times']) if data['response_times'] else 0
                daily_breakdown.append({
                    'date': date_str,
                    'requests': data['requests'],
                    'avg_response_time': round(avg_time, 2)
                })
            
            stats_data = {
                'total_requests': total_requests,
                'successful_requests': successful_requests,
                'success_rate': round((successful_requests / total_requests * 100) if total_requests > 0 else 0, 1),
                'avg_response_time': round(sum(response_times) / len(response_times) if response_times else 0, 2),
                'min_response_time': round(min(response_times) if response_times else 0, 2),
                'max_response_time': round(max(response_times) if response_times else 0, 2),
                'active_days': len(daily_data),
                'daily_breakdown': daily_breakdown
            }
            
            # Cache for shorter time due to changing data
            if REDIS_AVAILABLE:
                redis_client.setex(cache_key, 60, json.dumps(stats_data))
            
            return stats_data
            
        except Exception as e:
            print(f"Error getting customer stats: {e}")
            return {'error': str(e)}

# Initialize managers
customer_manager = None
dashboard_manager = DashboardManager()

# Proxy detection utilities
def get_client_ip(req):
    """Get real client IP considering proxy headers"""
    x_forwarded_for = req.headers.get('X-Forwarded-For')
    if x_forwarded_for:
        ips = [ip.strip() for ip in x_forwarded_for.split(',')]
        for ip_str in ips:
            try:
                ip_obj = ipaddress.ip_address(ip_str)
                if not ip_obj.is_private:
                    return ip_str
            except ValueError:
                continue
        return ips[0] if ips else req.remote_addr
    return req.remote_addr

def determine_anonymity(req, proxy_ip):
    """Determine proxy anonymity level"""
    via_header = req.headers.get('Via')
    x_forwarded_for = req.headers.get('X-Forwarded-For')
    connecting_ip = req.remote_addr

    if via_header or (x_forwarded_for and x_forwarded_for != connecting_ip):
        return "transparent"
    
    if proxy_ip and connecting_ip != proxy_ip:
        return "anonymous"
    
    return "elite"

def determine_speed(latency_ms):
    """Determine proxy speed from latency"""
    if latency_ms < 200:
        return "fast"
    elif latency_ms < 800:
        return "medium"
    else:
        return "slow"

# Helper function to determine response format
def get_response_format(request):
    """Determine response format based on request parameters and headers"""
    # Check URL parameter first
    format_param = request.args.get('format', '').lower()
    if format_param in ['json', 'text', 'xml', 'html']:
        return format_param
    
    # Check Accept header
    accept_header = request.headers.get('Accept', '').lower()
    if 'application/json' in accept_header:
        return 'json'
    elif 'text/plain' in accept_header:
        return 'text'
    elif 'text/html' in accept_header:
        return 'html'
    elif 'application/xml' in accept_header:
        return 'xml'
    
    # Default to JSON
    return 'json'

def format_response(data, format_type):
    """Format response data based on requested format"""
    if format_type == 'json':
        return Response(orjson.dumps(data), mimetype='application/json')
    
    elif format_type == 'text':
        # Simple text format
        text_lines = [
            f"Status: {data.get('status')}",
            f"IP: {data.get('connecting_ip')}",
            f"Anonymity: {data.get('anonymity_level')}",
            f"Speed: {data.get('speed_hint')}",
            f"Response Time: {data.get('server_processing_latency_ms', 0):.2f}ms"
        ]
        return Response('\n'.join(text_lines), mimetype='text/plain')
    
    elif format_type == 'xml':
        # Simple XML format
        xml_data = f"""<?xml version="1.0" encoding="UTF-8"?>
<proxy_test>
    <status>{data.get('status')}</status>
    <connecting_ip>{data.get('connecting_ip')}</connecting_ip>
    <anonymity_level>{data.get('anonymity_level')}</anonymity_level>
    <speed_hint>{data.get('speed_hint')}</speed_hint>
    <response_time_ms>{data.get('server_processing_latency_ms', 0):.2f}</response_time_ms>
</proxy_test>"""
        return Response(xml_data, mimetype='application/xml')
    
    elif format_type == 'html':
        # Pretty HTML format
        html_data = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Proxy Test Results</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }}
                .container {{ background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
                .result {{ padding: 10px; margin: 5px 0; background: #e9ecef; border-radius: 5px; }}
                .success {{ background: #d4edda; color: #155724; }}
                .speed-fast {{ color: #28a745; }}
                .speed-medium {{ color: #ffc107; }}
                .speed-slow {{ color: #dc3545; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>üîç Proxy Test Results</h1>
                <div class="result success">Status: {data.get('status')}</div>
                <div class="result">Connecting IP: <strong>{data.get('connecting_ip')}</strong></div>
                <div class="result">Client IP from Headers: <strong>{data.get('client_ip_from_headers')}</strong></div>
                <div class="result">Anonymity Level: <strong>{data.get('anonymity_level')}</strong></div>
                <div class="result speed-{data.get('speed_hint', 'medium')}">Speed: <strong>{data.get('speed_hint')}</strong></div>
                <div class="result">Response Time: <strong>{data.get('server_processing_latency_ms', 0):.2f}ms</strong></div>
                <div class="result">Method: {data.get('method')}</div>
                <div class="result">Path: {data.get('received_path')}</div>
            </div>
        </body>
        </html>
        """
        return Response(html_data, mimetype='text/html')
    
    # Fallback to JSON
    return Response(orjson.dumps(data), mimetype='application/json')

# Authentication decorators
def require_api_key(f):
    """Require API key authentication"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({'error': 'Missing or invalid Authorization header'}), 401
        
        api_key = auth_header.split(' ')[1]
        customer = Customer.query.filter_by(api_key=api_key, status='active').first()
        
        if not customer:
            return jsonify({'error': 'Invalid API key'}), 401
        
        # Check usage limits
        if customer.current_usage >= customer.monthly_quota:
            return jsonify({'error': 'Monthly quota exceeded'}), 429
        
        request.current_customer = customer
        return f(*args, **kwargs)
    
    return decorated_function

def require_whitelisted_ip(f):
    """Require whitelisted IP with ultra-fast checking"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        start_time = time.time()
        client_ip = get_client_ip(request)
        
        is_allowed, client_data = customer_manager.is_ip_allowed(client_ip)
        
        if not is_allowed:
            customer_manager.log_usage(client_ip, 'unknown', request.endpoint, 
                                     (time.time() - start_time) * 1000, False)
            return Response(orjson.dumps({
                'error': 'Access denied',
                'message': 'IP not whitelisted for service',
                'ip': client_ip,
                'contact': 'support@fastping.it.com'
            }), status=403, mimetype='application/json')
        
        if not customer_manager.check_rate_limit(client_ip, client_data['rate_limit']):
            customer_manager.log_usage(client_ip, client_data['customer_id'], 
                                     request.endpoint, (time.time() - start_time) * 1000, False)
            return Response(orjson.dumps({
                'error': 'Rate limit exceeded',
                'message': f"Rate limit: {client_data['rate_limit']} requests/minute",
                'plan': client_data['plan_type']
            }), status=429, mimetype='application/json')
        
        request.client_data = client_data
        result = f(*args, **kwargs)
        
        response_time = (time.time() - start_time) * 1000
        customer_manager.log_usage(client_ip, client_data['customer_id'], 
                                 request.endpoint, response_time, True)
        
        return result
    
    return decorated_function

def dashboard_token_required(f):
    """JWT token authentication decorator for dashboard"""
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            token = request.cookies.get('auth_token')
        
        if not token:
            return redirect(url_for('dashboard_login'))
        
        if token.startswith('Bearer '):
            token = token[7:]
        
        try:
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            current_customer = data['customer_id']
        except jwt.ExpiredSignatureError:
            return redirect(url_for('dashboard_login'))
        except jwt.InvalidTokenError:
            return redirect(url_for('dashboard_login'))
        
        return f(current_customer, *args, **kwargs)
    
    return decorated

# PayPal webhook handler
@app.route('/webhook/paypal', methods=['POST'])
def paypal_webhook():
    """Handle PayPal payment webhooks"""
    try:
        # Verify webhook signature
        if not verify_paypal_webhook(request):
            return jsonify({'error': 'Invalid webhook signature'}), 401
        
        webhook_data = request.json
        event_type = webhook_data.get('event_type')
        
        if event_type == 'PAYMENT.SALE.COMPLETED':
            # Extract customer info from payment
            payer_info = webhook_data['resource']['payer']['payer_info']
            email = payer_info.get('email')
            
            # Determine plan from amount (simplified)
            amount = float(webhook_data['resource']['amount']['total'])
            if amount >= 299:
                plan_type = 'enterprise'
            elif amount >= 99:
                plan_type = 'premium'
            else:
                plan_type = 'basic'
            
            # Create customer
            success, customer_id = customer_manager.create_customer_from_paypal(email, plan_type)
            
            if success:
                print(f"‚úÖ PayPal webhook: Customer {customer_id} created for {email}")
                return jsonify({'message': 'Customer created successfully', 'customer_id': customer_id})
            else:
                print(f"‚ùå PayPal webhook: Failed to create customer for {email}")
                return jsonify({'error': 'Failed to create customer'}), 500
        
        return jsonify({'message': 'Webhook processed'})
        
    except Exception as e:
        print(f"PayPal webhook error: {e}")
        return jsonify({'error': 'Webhook processing failed'}), 500

def verify_paypal_webhook(request):
    """Verify PayPal webhook signature"""
    # Simplified verification - implement full verification in production
    return True

# API Endpoints

# Ultra-fast ping endpoint
@app.route('/api/v1/ping', methods=['GET', 'POST'])
@require_api_key
@limiter.limit("1000 per minute")
def api_ping():
    """Ultra-fast ping endpoint for paid customers with flexible output"""
    start_time = time.time()
    
    customer = request.current_customer
    client_ip = get_client_ip(request)
    
    # Increment usage
    customer.current_usage += 1
    db.session.commit()
    
    response_time_ms = (time.time() - start_time) * 1000
    
    result = {
        'status': 'success',
        'message': 'FastPing service active',
        'timestamp': datetime.utcnow().isoformat(),
        'customer_id': customer.id,
        'plan': customer.plan_type,
        'usage': f"{customer.current_usage}/{customer.monthly_quota}",
        'client_ip': client_ip,
        'response_time_ms': round(response_time_ms, 2)
    }
    
    # Add format support
    format_type = get_response_format(request)
    return format_response(result, format_type)

# Enhanced API proxy detection endpoint
@app.route('/api/v1/proxy-test', methods=['GET', 'POST'])
@require_api_key
@limiter.limit("500 per minute")
def api_proxy_test():
    """Enhanced proxy detection via API with flexible output"""
    start_time = time.time()
    
    customer = request.current_customer
    connecting_ip = request.remote_addr
    client_ip_from_headers = get_client_ip(request)
    server_processing_latency_ms = (time.time() - start_time) * 1000
    anonymity_level = determine_anonymity(request, connecting_ip)
    
    # Increment usage
    customer.current_usage += 1
    db.session.commit()
    
    response_data = {
        "status": "success",
        "service": "FastPing API Proxy Test",
        "method": request.method,
        "headers": dict(request.headers),
        "connecting_ip": connecting_ip,
        "client_ip_from_headers": client_ip_from_headers,
        "anonymity_level": anonymity_level,
        "speed_hint": determine_speed(server_processing_latency_ms),
        "server_processing_latency_ms": round(server_processing_latency_ms, 2),
        "customer_id": customer.id,
        "plan": customer.plan_type,
        "usage": f"{customer.current_usage}/{customer.monthly_quota}",
        "timestamp": datetime.utcnow().isoformat()
    }
    
    # Add format support
    format_type = get_response_format(request)
    return format_response(response_data, format_type)

# API format-specific endpoints
@app.route('/api/v1/ping/json', methods=['GET', 'POST'])
@require_api_key
@limiter.limit("1000 per minute")
def api_ping_json():
    """API ping endpoint - force JSON output"""
    start_time = time.time()
    
    customer = request.current_customer
    client_ip = get_client_ip(request)
    
    # Increment usage
    customer.current_usage += 1
    db.session.commit()
    
    response_time_ms = (time.time() - start_time) * 1000
    
    result = {
        'status': 'success',
        'message': 'FastPing service active',
        'timestamp': datetime.utcnow().isoformat(),
        'customer_id': customer.id,
        'plan': customer.plan_type,
        'usage': f"{customer.current_usage}/{customer.monthly_quota}",
        'client_ip': client_ip,
        'response_time_ms': round(response_time_ms, 2)
    }
    
    return format_response(result, 'json')

@app.route('/api/v1/ping/text', methods=['GET', 'POST'])
@require_api_key
@limiter.limit("1000 per minute")
def api_ping_text():
    """API ping endpoint - force text output"""
    start_time = time.time()
    
    customer = request.current_customer
    client_ip = get_client_ip(request)
    
    # Increment usage
    customer.current_usage += 1
    db.session.commit()
    
    response_time_ms = (time.time() - start_time) * 1000
    
    result = {
        'status': 'success',
        'message': 'FastPing service active',
        'timestamp': datetime.utcnow().isoformat(),
        'customer_id': customer.id,
        'plan': customer.plan_type,
        'usage': f"{customer.current_usage}/{customer.monthly_quota}",
        'client_ip': client_ip,
        'response_time_ms': round(response_time_ms, 2)
    }
    
    return format_response(result, 'text')

@app.route('/api/v1/ping/xml', methods=['GET', 'POST'])
@require_api_key
@limiter.limit("1000 per minute")
def api_ping_xml():
    """API ping endpoint - force XML output"""
    start_time = time.time()
    
    customer = request.current_customer
    client_ip = get_client_ip(request)
    
    # Increment usage
    customer.current_usage += 1
    db.session.commit()
    
    response_time_ms = (time.time() - start_time) * 1000
    
    result = {
        'status': 'success',
        'message': 'FastPing service active',
        'timestamp': datetime.utcnow().isoformat(),
        'customer_id': customer.id,
        'plan': customer.plan_type,
        'usage': f"{customer.current_usage}/{customer.monthly_quota}",
        'client_ip': client_ip,
        'response_time_ms': round(response_time_ms, 2)
    }
    
    return format_response(result, 'xml')

@app.route('/api/v1/ping/html', methods=['GET', 'POST'])
@require_api_key
@limiter.limit("1000 per minute")
def api_ping_html():
    """API ping endpoint - force HTML output"""
    start_time = time.time()
    
    customer = request.current_customer
    client_ip = get_client_ip(request)
    
    # Increment usage
    customer.current_usage += 1
    db.session.commit()
    
    response_time_ms = (time.time() - start_time) * 1000
    
    result = {
        'status': 'success',
        'message': 'FastPing service active',
        'timestamp': datetime.utcnow().isoformat(),
        'customer_id': customer.id,
        'plan': customer.plan_type,
        'usage': f"{customer.current_usage}/{customer.monthly_quota}",
        'client_ip': client_ip,
        'response_time_ms': round(response_time_ms, 2)
    }
    
    return format_response(result, 'html')

# Proxy test endpoint (whitelisted IPs only)
@app.route('/proxy-test', defaults={'path': ''})
@app.route('/proxy-test/<path:path>')
@require_whitelisted_ip
def proxy_test_endpoint(path):
    """Ultra-fast proxy testing for whitelisted IPs with flexible output"""
    start_time = time.time()
    
    connecting_ip = request.remote_addr
    client_ip_from_headers = get_client_ip(request)
    server_processing_latency_ms = (time.time() - start_time) * 1000
    anonymity_level = determine_anonymity(request, connecting_ip)
    
    response_data = {
        "status": "success",
        "service": "FastPing Proxy Test",
        "path": f"/{path}",
        "method": request.method,
        "headers": dict(request.headers),
        "connecting_ip": connecting_ip,
        "client_ip_from_headers": client_ip_from_headers,
        "anonymity_level": anonymity_level,
        "speed_hint": determine_speed(server_processing_latency_ms),
        "server_processing_latency_ms": round(server_processing_latency_ms, 2),
        "plan": request.client_data['plan_type'],
        "timestamp": datetime.utcnow().isoformat()
    }
    
    # Determine response format and return accordingly
    format_type = get_response_format(request)
    return format_response(response_data, format_type)

# Dedicated format-specific endpoints for convenience
@app.route("/json")
@app.route("/json/<path:path>")
@require_whitelisted_ip
def json_endpoint(path=''):
    """Force JSON output"""
    start_time = time.time()
    
    connecting_ip = request.remote_addr
    client_ip_from_headers = get_client_ip(request)
    server_processing_latency_ms = (time.time() - start_time) * 1000
    anonymity_level = determine_anonymity(request, connecting_ip)
    
    response_data = {
        "status": "success",
        "service": "FastPing Proxy Test",
        "path": f"/{path}",
        "method": request.method,
        "headers": dict(request.headers),
        "connecting_ip": connecting_ip,
        "client_ip_from_headers": client_ip_from_headers,
        "anonymity_level": anonymity_level,
        "speed_hint": determine_speed(server_processing_latency_ms),
        "server_processing_latency_ms": round(server_processing_latency_ms, 2),
        "plan": request.client_data['plan_type'],
        "timestamp": datetime.utcnow().isoformat()
    }
    
    return format_response(response_data, 'json')

@app.route("/text")
@app.route("/text/<path:path>")
@require_whitelisted_ip
def text_endpoint(path=''):
    """Force text output"""
    start_time = time.time()
    
    connecting_ip = request.remote_addr
    client_ip_from_headers = get_client_ip(request)
    server_processing_latency_ms = (time.time() - start_time) * 1000
    anonymity_level = determine_anonymity(request, connecting_ip)
    
    response_data = {
        "status": "success",
        "service": "FastPing Proxy Test",
        "path": f"/{path}",
        "method": request.method,
        "headers": dict(request.headers),
        "connecting_ip": connecting_ip,
        "client_ip_from_headers": client_ip_from_headers,
        "anonymity_level": anonymity_level,
        "speed_hint": determine_speed(server_processing_latency_ms),
        "server_processing_latency_ms": round(server_processing_latency_ms, 2),
        "plan": request.client_data['plan_type'],
        "timestamp": datetime.utcnow().isoformat()
    }
    
    return format_response(response_data, 'text')

@app.route("/html")
@app.route("/html/<path:path>")
@require_whitelisted_ip
def html_endpoint(path=''):
    """Force HTML output"""
    start_time = time.time()
    
    connecting_ip = request.remote_addr
    client_ip_from_headers = get_client_ip(request)
    server_processing_latency_ms = (time.time() - start_time) * 1000
    anonymity_level = determine_anonymity(request, connecting_ip)
    
    response_data = {
        "status": "success",
        "service": "FastPing Proxy Test",
        "path": f"/{path}",
        "method": request.method,
        "headers": dict(request.headers),
        "connecting_ip": connecting_ip,
        "client_ip_from_headers": client_ip_from_headers,
        "anonymity_level": anonymity_level,
        "speed_hint": determine_speed(server_processing_latency_ms),
        "server_processing_latency_ms": round(server_processing_latency_ms, 2),
        "plan": request.client_data['plan_type'],
        "timestamp": datetime.utcnow().isoformat()
    }
    
    return format_response(response_data, 'html')

@app.route("/xml")
@app.route("/xml/<path:path>")
@require_whitelisted_ip
def xml_endpoint(path=''):
    """Force XML output"""
    start_time = time.time()
    
    connecting_ip = request.remote_addr
    client_ip_from_headers = get_client_ip(request)
    server_processing_latency_ms = (time.time() - start_time) * 1000
    anonymity_level = determine_anonymity(request, connecting_ip)
    
    response_data = {
        "status": "success",
        "service": "FastPing Proxy Test",
        "path": f"/{path}",
        "method": request.method,
        "headers": dict(request.headers),
        "connecting_ip": connecting_ip,
        "client_ip_from_headers": client_ip_from_headers,
        "anonymity_level": anonymity_level,
        "speed_hint": determine_speed(server_processing_latency_ms),
        "server_processing_latency_ms": round(server_processing_latency_ms, 2),
        "plan": request.client_data['plan_type'],
        "timestamp": datetime.utcnow().isoformat()
    }
    
    return format_response(response_data, 'xml')

# Health check
@app.route('/health')
def health():
    """Public health check"""
    return jsonify({
        'status': 'healthy',
        'service': 'FastPing Ultimate',
        'timestamp': datetime.utcnow().isoformat(),
        'redis': REDIS_AVAILABLE
    })

# Admin dashboard
@app.route('/admin/stats')
def admin_stats():
    """Admin statistics dashboard"""
    stats = {
        'total_customers': Customer.query.count(),
        'active_customers': Customer.query.filter_by(status='active').count(),
        'total_allocations': ResourceAllocation.query.filter_by(is_active=True).count(),
        'available_resources': ResourcePool.query.filter_by(is_available=True).count(),
        'total_requests_today': UsageLog.query.filter(
            UsageLog.timestamp >= datetime.utcnow().replace(hour=0, minute=0, second=0)
        ).count(),
        'redis_status': 'connected' if REDIS_AVAILABLE else 'disconnected'
    }
    
    # Recent customers
    recent_customers = Customer.query.order_by(Customer.created_at.desc()).limit(10).all()
    
    dashboard_html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>FastPing Admin Dashboard</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
            .dashboard {{ background: white; padding: 20px; border-radius: 10px; }}
            .stat {{ display: inline-block; margin: 10px; padding: 15px; background: #007bff; color: white; border-radius: 5px; }}
            .customers {{ margin-top: 20px; }}
            table {{ width: 100%; border-collapse: collapse; }}
            th, td {{ padding: 10px; border: 1px solid #ddd; text-align: left; }}
            th {{ background: #f8f9fa; }}
        </style>
    </head>
    <body>
        <div class="dashboard">
            <h1>üöÄ FastPing Admin Dashboard</h1>
            
            <div class="stats">
                <div class="stat">Total Customers: {stats['total_customers']}</div>
                <div class="stat">Active: {stats['active_customers']}</div>
                <div class="stat">Resources Used: {stats['total_allocations']}</div>
                <div class="stat">Available: {stats['available_resources']}</div>
                <div class="stat">Requests Today: {stats['total_requests_today']}</div>
                <div class="stat">Redis: {stats['redis_status']}</div>
            </div>
            
            <div class="customers">
                <h2>Recent Customers</h2>
                <table>
                    <tr>
                        <th>Customer ID</th>
                        <th>Email</th>
                        <th>Plan</th>
                        <th>Status</th>
                        <th>Usage</th>
                        <th>Created</th>
                    </tr>
                    {''.join([f'''
                    <tr>
                        <td>{c.id}</td>
                        <td>{c.email}</td>
                        <td>{c.plan_type}</td>
                        <td>{c.status}</td>
                        <td>{c.current_usage}/{c.monthly_quota}</td>
                        <td>{c.created_at.strftime('%Y-%m-%d %H:%M')}</td>
                    </tr>
                    ''' for c in recent_customers])}
                </table>
            </div>
        </div>
    </body>
    </html>
    """
    
    return dashboard_html

# Test customer creation endpoint
@app.route('/admin/create_test_customer', methods=['POST'])
def create_test_customer():
    """Create test customer for development"""
    data = request.get_json()
    email = data.get('email', f'test_{int(time.time())}@fastping.dev')
    plan = data.get('plan_type', 'basic')
    
    success, customer_id = customer_manager.create_customer_from_paypal(email, plan)
    
    if success:
        customer = Customer.query.get(customer_id)
        resources = ResourceAllocation.query.filter_by(customer_id=customer_id, is_active=True).all()
        
        return jsonify({
            'success': True,
            'customer_id': customer_id,
            'api_key': customer.api_key,
            'plan': customer.plan_type,
            'allocated_ips': [r.ip_address for r in resources],
            'quota': customer.monthly_quota
        })
    else:
        return jsonify({'success': False, 'error': customer_id}), 400

# DASHBOARD HTML TEMPLATES
DASHBOARD_HTML = '''
<!DOCTYPE html>
<html>
<head>
    <title>FastPing Customer Dashboard</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            --primary: #1a73e8;
            --primary-dark: #1557b0;
            --bg-light: #f8f9fa;
            --text-muted: #666;
            transition: all 0.8s ease;
        }
        
        /* Theme color definitions */
        .theme-blue { --primary: #1a73e8; --primary-dark: #1557b0; }
        .theme-purple { --primary: #7c3aed; --primary-dark: #5b21b6; }
        .theme-green { --primary: #059669; --primary-dark: #047857; }
        .theme-orange { --primary: #ea580c; --primary-dark: #c2410c; }
        .theme-pink { --primary: #e11d48; --primary-dark: #be185d; }
        .theme-teal { --primary: #0891b2; --primary-dark: #0e7490; }
        .theme-indigo { --primary: #4f46e5; --primary-dark: #3730a3; }
        .theme-red { --primary: #dc2626; --primary-dark: #b91c1c; }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            margin: 0; padding: 20px; background: #f5f5f5;
            transition: all 0.8s ease;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .card { 
            background: white; border-radius: 8px; padding: 20px; margin: 20px 0; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.8s ease;
        }
        .header { 
            background: var(--primary); color: white; padding: 20px; 
            border-radius: 8px; margin-bottom: 20px;
            transition: all 0.8s ease;
        }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; }
        .stat-box { 
            text-align: center; padding: 20px; background: var(--bg-light); 
            border-radius: 8px; transition: all 0.8s ease;
        }
        .stat-number { 
            font-size: 2em; font-weight: bold; color: var(--primary);
            transition: all 0.8s ease;
        }
        .stat-label { color: var(--text-muted); margin-top: 5px; }
        .ip-list { list-style: none; padding: 0; }
        .ip-item { 
            background: var(--bg-light); margin: 10px 0; padding: 15px; 
            border-radius: 8px; display: flex; justify-content: space-between; align-items: center;
            transition: all 0.8s ease;
        }
        .plan-badge { 
            background: var(--primary); color: white; padding: 4px 8px; 
            border-radius: 4px; font-size: 0.8em;
            transition: all 0.8s ease;
        }
        .refresh-btn { 
            background: var(--primary); color: white; border: none; 
            padding: 10px 20px; border-radius: 4px; cursor: pointer;
            transition: all 0.8s ease;
        }
        .refresh-btn:hover { background: var(--primary-dark); }
        .api-key { 
            font-family: monospace; background: var(--bg-light); 
            padding: 10px; border-radius: 4px; word-break: break-all;
            transition: all 0.8s ease;
        }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { 
            background: var(--bg-light);
            transition: all 0.8s ease;
        }
        
        /* Theme indicator */
        .theme-indicator {
            position: fixed; top: 20px; right: 20px; 
            background: var(--primary); color: white;
            padding: 8px 12px; border-radius: 20px; font-size: 0.8em;
            opacity: 0.8; transition: all 0.8s ease;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="theme-indicator" id="themeIndicator">üé® Blue Ocean</div>
    
    <div class="container">
        <div class="header">
            <h1>üöÄ FastPing Customer Dashboard</h1>
            <p>Customer: {{ customer_data.email }} | ID: {{ customer_data.customer_id }}</p>
        </div>
        
        <div class="card">
            <h2>üìä Usage Statistics (Last 7 Days)</h2>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-number">{{ stats.total_requests }}</div>
                    <div class="stat-label">Total Requests</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">{{ "%.1f"|format(stats.success_rate) }}%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">{{ stats.avg_response_time }}ms</div>
                    <div class="stat-label">Avg Response Time</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">{{ stats.active_days }}</div>
                    <div class="stat-label">Active Days</div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>üîê Your Whitelisted Resources</h2>
            {% if config.ips %}
            <ul class="ip-list">
                {% for ip in config.ips %}
                <li class="ip-item">
                    <div>
                        <strong>{{ ip.ip_address }}</strong>
                        <div style="color: #666; font-size: 0.9em;">{{ ip.notes }}</div>
                    </div>
                    <div>
                        <span class="plan-badge">{{ ip.plan_type.upper() }}</span>
                        <span style="margin-left: 10px;">{{ ip.rate_limit }}/min</span>
                    </div>
                </li>
                {% endfor %}
            </ul>
            {% else %}
            <p>No resources allocated yet. Contact support to get started!</p>
            {% endif %}
        </div>
        
        <div class="card">
            <h2>üîë API Access</h2>
            <p><strong>Your API Key:</strong></p>
            <div class="api-key">{{ customer_data.api_key }}</div>
            <p style="color: #666; font-size: 0.9em;">Use this key for programmatic access to FastPing APIs.</p>
            
            <h3>üì° API Endpoints:</h3>
            <ul>
                <li><code>GET /api/v1/ping</code> - Basic service ping</li>
                <li><code>GET /api/v1/proxy-test</code> - Proxy detection & analysis</li>
                <li><code>GET /proxy-test</code> - Whitelisted IP proxy test</li>
            </ul>
        </div>
        
        {% if stats.daily_breakdown %}
        <div class="card">
            <h2>üìà Daily Breakdown</h2>
            <table>
                <thead>
                    <tr><th>Date</th><th>Requests</th><th>Avg Response Time</th></tr>
                </thead>
                <tbody>
                    {% for day in stats.daily_breakdown %}
                    <tr>
                        <td>{{ day.date }}</td>
                        <td>{{ day.requests }}</td>
                        <td>{{ day.avg_response_time }}ms</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
        {% endif %}
        
        <div class="card">
            <button class="refresh-btn" onclick="location.reload()">üîÑ Refresh Data</button>
            <button class="refresh-btn" onclick="logout()" style="background: #dc3545; margin-left: 10px;">üö™ Logout</button>
        </div>
    </div>
    
    <script>
        // Theme cycling system
        const themes = [
            { name: 'Blue Ocean', class: 'theme-blue', emoji: 'üåä' },
            { name: 'Purple Storm', class: 'theme-purple', emoji: '‚ö°' },
            { name: 'Forest Green', class: 'theme-green', emoji: 'üå≤' },
            { name: 'Sunset Orange', class: 'theme-orange', emoji: 'üåÖ' },
            { name: 'Rose Pink', class: 'theme-pink', emoji: 'üåπ' },
            { name: 'Ocean Teal', class: 'theme-teal', emoji: 'üèùÔ∏è' },
            { name: 'Cosmic Indigo', class: 'theme-indigo', emoji: 'üåå' },
            { name: 'Fire Red', class: 'theme-red', emoji: 'üî•' }
        ];
        
        let currentThemeIndex = 0;
        
        function cycleTheme() {
            document.body.className = '';
            const theme = themes[currentThemeIndex];
            document.body.classList.add(theme.class);
            document.getElementById('themeIndicator').innerHTML = `${theme.emoji} ${theme.name}`;
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
        }
        
        function logout() {
            document.cookie = 'auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
            window.location.href = '/dashboard/login';
        }
        
        cycleTheme();
        setInterval(cycleTheme, 45000);
        setTimeout(() => location.reload(), 30000);
    </script>
</body>
</html>
'''

LOGIN_HTML = '''
<!DOCTYPE html>
<html>
<head>
    <title>FastPing Customer Login</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        .login-card { background: white; border-radius: 8px; padding: 40px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); width: 100%; max-width: 400px; }
        .header { text-align: center; margin-bottom: 30px; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; color: #333; }
        input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        .login-btn { background: #1a73e8; color: white; border: none; padding: 12px; border-radius: 4px; cursor: pointer; width: 100%; font-size: 16px; }
        .login-btn:hover { background: #1557b0; }
        .error { color: #dc3545; margin-top: 10px; }
    </style>
</head>
<body>
    <div class="login-card">
        <div class="header">
            <h1>üöÄ FastPing</h1>
            <p>Customer Dashboard Login</p>
        </div>
        
        <form method="post">
            <div class="form-group">
                <label for="email">Email:</label>
                <input type="email" id="email" name="email" required>
            </div>
            
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" required>
            </div>
            
            <button type="submit" class="login-btn">üîê Login</button>
            
            {% if error %}
            <div class="error">{{ error }}</div>
            {% endif %}
        </form>
    </div>
</body>
</html>
'''

# DASHBOARD ROUTES
@app.route('/dashboard/login', methods=['GET', 'POST'])
def dashboard_login():
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        
        customer_data = dashboard_manager.authenticate_customer(email, password)
        
        if customer_data:
            # Create JWT token
            token = jwt.encode(
                {
                    'customer_id': customer_data['customer_id'],
                    'email': customer_data['email'],
                    'exp': datetime.utcnow() + timedelta(hours=JWT_EXPIRY_HOURS)
                },
                app.config['SECRET_KEY'],
                algorithm='HS256'
            )
            
            response = redirect(url_for('dashboard_home'))
            response.set_cookie('auth_token', token, max_age=JWT_EXPIRY_HOURS*3600, httponly=True)
            return response
        else:
            return render_template_string(LOGIN_HTML, error="Invalid credentials")
    
    return render_template_string(LOGIN_HTML)

@app.route('/dashboard')
@dashboard_token_required
def dashboard_home(current_customer):
    # Get customer data
    config = dashboard_manager.get_customer_config(current_customer)
    stats = dashboard_manager.get_customer_stats(current_customer)
    
    # Get customer info
    customer = Customer.query.get(current_customer)
    customer_data = {
        'customer_id': current_customer,
        'email': customer.email if customer else 'Unknown',
        'api_key': customer.api_key if customer else 'No API key'
    }
    
    return render_template_string(DASHBOARD_HTML, 
                                customer_data=customer_data,
                                config=config or {'ips': []},
                                stats=stats)

# Dashboard API endpoints
@app.route('/dashboard/api/stats')
@dashboard_token_required
def dashboard_api_stats(current_customer):
    days = request.args.get('days', 7, type=int)
    stats = dashboard_manager.get_customer_stats(current_customer, days)
    return jsonify(stats)

@app.route('/dashboard/api/config')
@dashboard_token_required
def dashboard_api_config(current_customer):
    config = dashboard_manager.get_customer_config(current_customer)
    return jsonify(config)

# Redirect root to dashboard
@app.route('/')
def root():
    return redirect(url_for('dashboard_login'))

# Admin route to create dashboard account for existing customer
@app.route('/admin/create_dashboard_account', methods=['POST'])
def create_dashboard_account():
    customer_id = request.form.get('customer_id')
    email = request.form.get('email')
    password = request.form.get('password')
    
    success = dashboard_manager.create_dashboard_account(customer_id, email, password)
    
    return jsonify({'success': success})

# Initialize database and customer manager
def initialize_app():
    """Initialize database tables and customer manager"""
    global customer_manager
    
    # Ensure data directory exists
    data_dir = os.path.dirname('fastping.db')
    if data_dir and not os.path.exists(data_dir):
        os.makedirs(data_dir, exist_ok=True)
        print(f"‚úÖ Created directory: {data_dir}")
    
    # Create all database tables
    db.create_all()
    print("‚úÖ Database tables created")
    
    # Now we can safely create the customer manager
    customer_manager = UltimateCustomerManager()
    
    # Create test customer if none exist
    if Customer.query.count() == 0:
        print("Creating test customer...")
        success, customer_id = customer_manager.create_customer_from_paypal(
            'test@fastping.dev', 'enterprise'
        )
        if success:
            test_customer = Customer.query.get(customer_id)
            print(f"‚úÖ Test customer created:")
            print(f"   Customer ID: {customer_id}")
            print(f"   API Key: {test_customer.api_key}")
            print(f"   Plan: {test_customer.plan_type}")

# Call initialization when app starts
with app.app_context():
    initialize_app()

if __name__ == '__main__':
    print("üöÄ Starting Ultimate FastPing Service + Customer Dashboard...")
    print("‚úÖ Features enabled:")
    print("   - FastPing API with authentication")
    print("   - IP whitelisting with Redis caching") 
    print("   - Automatic customer provisioning")
    print("   - Proxy testing capabilities")
    print("   - Complete billing system")
    print("   - Resource management")
    print("   - PayPal webhook integration")
    print("   - üé® BEAUTIFUL Customer Dashboard with color themes!")
    print("   - JWT authentication for dashboard")
    print("   - Real-time usage statistics")
    print("")
    print("üåê Endpoints:")
    print("   - Customer Dashboard: http://localhost:9876/dashboard")
    print("   - Health: http://localhost:9876/health")
    print("   - Admin: http://localhost:9876/admin/stats")
    print("   - API Ping: http://localhost:9876/api/v1/ping")
    print("   - Proxy Test: http://localhost:9876/proxy-test")
    print("   - PayPal Webhook: http://localhost:9876/webhook/paypal")
    
    app.run(host='0.0.0.0', port=9876, debug=False)